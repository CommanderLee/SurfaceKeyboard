# Some functions about standard keyboard and its layout.
# Zhen Li, Tsinghua University.
import matplotlib.pyplot as plt
from pylab import *
from matplotlib.patches import Ellipse, Rectangle
import Tkinter, tkFileDialog
import random as rd

from constants import *

def loadKeyboardLayout(fName):
    "Load Keyboard Layout from File (generated by JMP)"

    # char,lines,mean(absX),mean(absY),std(absX),std(absY)
    # Hint: '(', ')' will be removed by the function numpy.genfromtxt 
    dataCSV = np.genfromtxt(fName, dtype = None, delimiter = ',', names = True)

    letters = dataCSV['char']

    posX = dataCSV['meanabsX']
    stdX = dataCSV['stdabsX']

    posY = dataCSV['meanabsY']
    stdY = dataCSV['stdabsY']

    colors = ['b', 'c', 'g', 'm', 'c', 'y', 'b', 'c', 'g', 'y', 'c', 'm']
    colorLen = len(colors)

    ells = [Ellipse(xy=(posX[i], posY[i]), width=stdX[i]*2, height=stdY[i]*2) for i in range(len(posX))]

    fig = figure(0)
    # ax = fig.add_subplot(111, aspect='equal')
    ax = gca()
    for i in range(len(ells)):
    # for e in ells:
        ax.add_artist(ells[i])
        ells[i].set_facecolor(colors[i % colorLen])
        # e.set_clip_box(ax.bbox)
        ells[i].set_alpha(0.6)
        # e.set_facecolor(rand(3))

    # plt.figure()
    # plt.gcf()
    # for (pX, sX, pY, sY, ch) in zip(posX, stdX, posY, stdY, letters):
    for (pX, pY, ch) in zip(posX, posY, letters):
        # print (pX, sX, pY, sY, ch)
        # ellipse = Ellipse(xy = (pX, pY), width = stdX * 2, height = stdY * 2, edgecolor=colors[rd.randint(0, colorLen-1)])
        # gca().add_patch(ellipse)
        plt.text(pX, pY, ch.strip('\''), 
            verticalalignment = 'center', horizontalalignment = 'center', 
            color = 'k', fontsize = 15)

    # ax.set_xlim(400, 1500)
    # ax.set_ylim(400, 1500)
    # ax.invert_yaxis()

    # show()

    # posXInt = [int(i) for i in posX]
    # posYInt = [int(j) for j in posY]
    return [posX, posY]

def calcKeyboardLayout():
    "Calculate Keyboard Layout( Size and Coordinate )"

    letterRow = ['qwertyuiop', 'asdfghjkl', 'zxcvbnm']
    # Data from Surface 2.0 standard keyboard.

    kbdImgTopLeft = [617.5, 500.4]

    # Coordinate for 'Q','P'x, 'Space'y
    # startX = 98.0
    # startY = 59.0
    # endX = 543.0
    # endY = 247.0

    # TODO: How to do normalization?
    # rangeX = endX - startX
    # rangeY = endY - startY

    # Coordinate for 'Q', 'A', 'Z'
    qX1, qY1 = 89, 52
    qX2, qY2 = 126, 92
    aX1, aY1 = 108, 97
    aX2, aY2 = 145, 137
    zX1, zY1 = 129, 140
    zX2, zY2 = 166, 180
    gapX = 41

    # Spacebar
    spaceX1, spaceY1 = 149, 184
    spaceX2, spaceY2 = 348, 223

    y = [kbdImgTopLeft[1] + (qY1 + qY2) / 2, 
    kbdImgTopLeft[1] + (aY1 + aY2) / 2, 
    kbdImgTopLeft[1] + (zY1 + zY2) / 2]
    # y = [(yi - startY) for yi in y]

    x = [[], [], []]
    x[0] = [((qX1 + qX2) / 2 + i * gapX + kbdImgTopLeft[0]) for i in range(0, 10)]
    x[1] = [((aX1 + aX2) / 2 + i * gapX + kbdImgTopLeft[0]) for i in range(0, 9)]
    x[2] = [((zX1 + zX2) / 2 + i * gapX + kbdImgTopLeft[0]) for i in range(0, 7)]

    # Position of each letter in normalized layout
    posX = range(0, 26)
    posY = range(0, 26)

    keySizeX = 39.0
    keySizeY = 42.0

    fig = figure(0)
    ax = gca()

    rec = Rectangle(xy=(spaceX1 + kbdImgTopLeft[0], spaceY1 + kbdImgTopLeft[1]), 
        width=spaceX2 - spaceX1, height=spaceY2 - spaceY1)
    ax.add_artist(rec)
    rec.set_facecolor('r')
    rec.set_alpha(0.15)

    for row in range(0, 3):
        colNum = len(x[row])
        for col in range(0, colNum):
            currLetter = letterRow[row][col]
            currNo = ord(currLetter) - ord('a')
            posX[currNo] = x[row][col]
            posY[currNo] = y[row]

            # plot(x[row][col], y[row], 'ro', markersize = 40)
            rec = Rectangle(xy=(x[row][col] - keySizeX/2, y[row] - keySizeY/2), 
                width=keySizeX, height=keySizeY)
            ax.add_artist(rec)
            rec.set_facecolor('r')
            rec.set_alpha(0.3)

            plt.text(x[row][col], y[row], currLetter,
                verticalalignment = 'center', horizontalalignment = 'center',
                color = 'b', fontsize = 10)
    
    # ax.set_xlim(400, 1500)
    # ax.set_ylim(400, 1500)
    # ax.invert_yaxis()

    # plt.show()
    return [posX, posY]

def calcWordVec(word):
    "Calculate word vector & points within each hand"
    # Return one point as well. (also in vec list, but it is not a vector)
    pntIdL, pntIdR = [], []
    vecL, vecR = [], []

    for char in word:
        charNo = ord(char) - ord('a')
        if handCode[charNo + 1] == '0':
            if len(pntIdL) > 0:
                vecL.append((letterPosX[charNo] - letterPosX[pntIdL[-1]], letterPosY[charNo] - letterPosY[pntIdL[-1]]))
            pntIdL.append(charNo)
        else:
            if len(pntIdR) > 0:
                vecR.append((letterPosX[charNo] - letterPosX[pntIdR[-1]], letterPosY[charNo] - letterPosY[pntIdR[-1]]))
            pntIdR.append(charNo)

    pntL = [(letterPosX[i], letterPosY[i]) for i in pntIdL]
    pntR = [(letterPosX[i], letterPosY[i]) for i in pntIdR]
    return [pntL, pntR, vecL, vecR]

def encode(word):
    "Encode the word using handCode rules."
    code = ''
    for char in word:
        code += handCode[ord(char) - ord('a') + 1]
    return code

def calcUserCodes(pntListX, midX, rangeX):
    "Calculate the user codes using recursion"
    codes = []
    if len(pntListX) == 1:
        suffixCodes = ['']
    else:
        suffixCodes = calcUserCodes(pntListX[1:], midX, rangeX)
    # Using a experimental constant. TODO: Using a probability model
    relativePos = (pntListX[0] - midX) / rangeX
    if abs(relativePos) < 0.05:
        for suffix in suffixCodes:
            codes.append('0' + suffix)
            codes.append('1' + suffix)
    elif pntListX[0] < midX:
        for suffix in suffixCodes:
            codes.append('0' + suffix)
    else:
        for suffix in suffixCodes:
            codes.append('1' + suffix)
    return codes
    
if __name__ == '__main__':
    tkObj = Tkinter.Tk()
    tkObj.file_opt = options = {}
    pointFile = tkFileDialog.askopenfile('r')

    if pointFile:
        [userX, userY] = loadKeyboardLayout(pointFile.name)
        print 'Number: %d' % (len(userX[1:]))
        print 'userPosX = [' + ', '.join([str(i) for i in userX[1:]]) + ']'
        print 'userPosY = [' + ', '.join([str(i) for i in userY[1:]]) + ']'

    print '--------------\n'

    [posX, posY] = calcKeyboardLayout()
    print 'Number: %d' % (len(posX))
    print 'letterPosX = [' + ', '.join([str(i) for i in posX]) + ']'
    print 'letterPosY = [' + ', '.join([str(i) for i in posY]) + ']'

    ax = gca()
    ax.set_xlim(400, 1500)
    ax.set_ylim(400, 1500)
    ax.invert_yaxis()

    plt.show()
    # plt.title('Surface Keyboard Layout')
    # gca().invert_yaxis()
    # plt.show()

    # [pntIdL, pntIdR, vecL, vecR] = calcWordVec('dog')
    # print [pntIdL, pntIdR, vecL, vecR]




