# Some functions about standard keyboard and its layout.
# Zhen Li, Tsinghua University.
import matplotlib.pyplot as plt
from pylab import *
from matplotlib.patches import Ellipse, Rectangle
import Tkinter, tkFileDialog
import random as rd
import numpy as np
import math
import pickle

from constants import *

def loadKeyboardLayout(fName):
    "Load Keyboard Layout from File (generated by JMP)"

    # char,lines,mean(absX),mean(absY),std(absX),std(absY)
    # Hint: '(', ')' will be removed by the function numpy.genfromtxt 
    dataCSV = np.genfromtxt(fName, dtype = None, delimiter = ',', names = True)

    letters = dataCSV['char']

    posX = dataCSV['meanabsX']
    stdX = dataCSV['stdabsX']

    posY = dataCSV['meanabsY']
    stdY = dataCSV['stdabsY']

    colors = ['b', 'c', 'g', 'm', 'c', 'y', 'b', 'c', 'g', 'y', 'c', 'm']
    colorLen = len(colors)

    ells = [Ellipse(xy=(posX[i], posY[i]), width=stdX[i]*2, height=stdY[i]*2) for i in range(len(posX))]

    fig = figure(0)
    # ax = fig.add_subplot(111, aspect='equal')
    ax = gca()
    for i in range(len(ells)):
    # for e in ells:
        ax.add_artist(ells[i])
        ells[i].set_facecolor(colors[i % colorLen])
        # e.set_clip_box(ax.bbox)
        ells[i].set_alpha(0.6)
        # e.set_facecolor(rand(3))

    # plt.figure()
    # plt.gcf()
    # for (pX, sX, pY, sY, ch) in zip(posX, stdX, posY, stdY, letters):
    for (pX, pY, ch) in zip(posX, posY, letters):
        # print (pX, sX, pY, sY, ch)
        # ellipse = Ellipse(xy = (pX, pY), width = stdX * 2, height = stdY * 2, edgecolor=colors[rd.randint(0, colorLen-1)])
        # gca().add_patch(ellipse)
        plt.text(pX, pY, ch.strip('\''), 
            verticalalignment = 'center', horizontalalignment = 'center', 
            color = 'k', fontsize = 15)

    # Print Left-Right Hand Margin
    xTY = (posX[ord('t')-ord('a')+1] + posX[ord('y')-ord('a')+1]) / 2
    yTY = (posY[ord('t')-ord('a')+1] + posY[ord('y')-ord('a')+1]) / 2
    xBN = (posX[ord('b')-ord('a')+1] + posX[ord('n')-ord('a')+1]) / 2
    yBN = (posY[ord('b')-ord('a')+1] + posY[ord('n')-ord('a')+1]) / 2

    paramA = (yBN - yTY) / (xBN - xTY)
    paramB = yBN - paramA * xBN

    print '(%f,%f) - (%f,%f) -> y = %f*x + %f' % (xTY, yTY, xBN, yBN, paramA, paramB)

    # Check a-z:
    print 'Check model'
    for (pX, pY, ch) in zip(posX, posY, letters):
        char = ch.strip('\'')
        if char != '-':
            y = paramA * pX + paramB
            code = '2'
            if y <= pY:
                code = '0'
            else:
                code = '1'

            if code == handCode[ord(char)-ord('a')+1]:
                print '    Correct: %s, %s, %f' % (char, code, y - pY)
            else:
                print 'Wrong: %s, %s, %f' % (char, code, y - pY)

    # ax.set_xlim(400, 1500)
    # ax.set_ylim(400, 1500)
    # ax.invert_yaxis()

    # show()

    # posXInt = [int(i) for i in posX]
    # posYInt = [int(j) for j in posY]
    return [posX, posY]

def calcKeyboardLayout():
    "Calculate Keyboard Layout( Size and Coordinate )"

    letterRow = ['qwertyuiop', 'asdfghjkl', 'zxcvbnm']
    # Data from Surface 2.0 standard keyboard.

    kbdImgTopLeft = [617.5, 500.4]

    # Coordinate for 'Q','P'x, 'Space'y
    # startX = 98.0
    # startY = 59.0
    # endX = 543.0
    # endY = 247.0

    # TODO: How to do normalization?
    # rangeX = endX - startX
    # rangeY = endY - startY

    # Coordinate for 'Q', 'A', 'Z'
    qX1, qY1 = 89, 52
    qX2, qY2 = 126, 92
    aX1, aY1 = 108, 97
    aX2, aY2 = 145, 137
    zX1, zY1 = 129, 140
    zX2, zY2 = 166, 180
    gapX = 41

    # Spacebar
    spaceX1, spaceY1 = 149, 184
    spaceX2, spaceY2 = 348, 223

    y = [kbdImgTopLeft[1] + (qY1 + qY2) / 2, 
    kbdImgTopLeft[1] + (aY1 + aY2) / 2, 
    kbdImgTopLeft[1] + (zY1 + zY2) / 2]
    # y = [(yi - startY) for yi in y]

    x = [[], [], []]
    x[0] = [((qX1 + qX2) / 2 + i * gapX + kbdImgTopLeft[0]) for i in range(0, 10)]
    x[1] = [((aX1 + aX2) / 2 + i * gapX + kbdImgTopLeft[0]) for i in range(0, 9)]
    x[2] = [((zX1 + zX2) / 2 + i * gapX + kbdImgTopLeft[0]) for i in range(0, 7)]

    # Position of each letter in normalized layout
    posX = range(0, 26)
    posY = range(0, 26)

    keySizeX = 39.0
    keySizeY = 42.0

    fig = figure(0)
    ax = gca()

    rec = Rectangle(xy=(spaceX1 + kbdImgTopLeft[0], spaceY1 + kbdImgTopLeft[1]), 
        width=spaceX2 - spaceX1, height=spaceY2 - spaceY1)
    ax.add_artist(rec)
    rec.set_facecolor('r')
    rec.set_alpha(0.15)

    for row in range(0, 3):
        colNum = len(x[row])
        for col in range(0, colNum):
            currLetter = letterRow[row][col]
            currNo = ord(currLetter) - ord('a')
            posX[currNo] = x[row][col]
            posY[currNo] = y[row]

            # plot(x[row][col], y[row], 'ro', markersize = 40)
            rec = Rectangle(xy=(x[row][col] - keySizeX/2, y[row] - keySizeY/2), 
                width=keySizeX, height=keySizeY)
            ax.add_artist(rec)
            rec.set_facecolor('r')
            rec.set_alpha(0.3)

            plt.text(x[row][col], y[row], currLetter,
                verticalalignment = 'center', horizontalalignment = 'center',
                color = 'b', fontsize = 10)
    
    # ax.set_xlim(400, 1500)
    # ax.set_ylim(400, 1500)
    # ax.invert_yaxis()

    # plt.show()
    return [posX, posY]

def calcWordVec(word, vecParams):
    "Calculate word vector & points within each hand"
    
    pntIdL, pntIdR = [], []
    vecL, vecR = [], []

    for i in range(len(word)):
        char = word[i]
        charNo = ord(char) - ord('a')
        if handCode[charNo + 1] == '0':
            if len(pntIdL) > 0:
                charPair = word[pntIdL[-1]] + char
                vecL.append(vecParams[charPair])
            pntIdL.append(i)
        else:
            if len(pntIdR) > 0:
                charPair = word[pntIdR[-1]] + char
                vecR.append(vecParams[charPair])
            pntIdR.append(i)

    # for char in word:
    #     charNo = ord(char) - ord('a')
    #     if handCode[charNo + 1] == '0':
    #         if len(pntIdL) > 0:
    #             vecL.append((letterPosX[charNo] - letterPosX[pntIdL[-1]], letterPosY[charNo] - letterPosY[pntIdL[-1]]))
    #         pntIdL.append(charNo)
    #     else:
    #         if len(pntIdR) > 0:
    #             vecR.append((letterPosX[charNo] - letterPosX[pntIdR[-1]], letterPosY[charNo] - letterPosY[pntIdR[-1]]))
    #         pntIdR.append(charNo)

    # pntL = [(userPosX[ord(word[i])-ord('a')], userPosY[ord(word[i])-ord('a')]) for i in pntIdL]
    # pntR = [(userPosX[ord(word[i])-ord('a')], userPosY[ord(word[i])-ord('a')]) for i in pntIdR]
    pntL = [(letterPosX[ord(word[i])-ord('a')], letterPosY[ord(word[i])-ord('a')]) for i in pntIdL]
    pntR = [(letterPosX[ord(word[i])-ord('a')], letterPosY[ord(word[i])-ord('a')]) for i in pntIdR]
    # pntL = [(letterPosX[i], letterPosY[i]) for i in pntIdL]
    # pntR = [(letterPosX[i], letterPosY[i]) for i in pntIdR]
    return [pntL, pntR, vecL, vecR]

def encode(word):
    "Encode the word using handCode rules."
    code = ''
    for char in word:
        code += handCode[ord(char) - ord('a') + 1]
    return code

# def calcUserCodes(pntListX, midX, rangeX):
def calcUserCodes(pntListX, pntListY):
    "Calculate the user codes using recursion"

    codes = []
    if len(pntListX) == 1:
        suffixCodes = ['']
    else:
        # suffixCodes = calcUserCodes(pntListX[1:], midX, rangeX)
        suffixCodes = calcUserCodes(pntListX[1:], pntListY[1:])

    # Using a experimental constant. TODO: Using a probability model
    y = paramA * pntListX[0] + paramB
    if y < pntListY[0] - 100:
        # Left
        for suffix in suffixCodes:
            codes.append('0' + suffix)
    elif y > pntListY[0] + 100:
        # Right
        for suffix in suffixCodes:
            codes.append('1' + suffix)
    else:
        # Middle, Try both
        for suffix in suffixCodes:
            codes.append('0' + suffix)
            codes.append('1' + suffix)

    # relativePos = (pntListX[0] - midX) / rangeX
    # if abs(relativePos) < 0.05:
    #     for suffix in suffixCodes:
    #         codes.append('0' + suffix)
    #         codes.append('1' + suffix)
    # elif pntListX[0] < midX:
    #     for suffix in suffixCodes:
    #         codes.append('0' + suffix)
    # else:
    #     for suffix in suffixCodes:
    #         codes.append('1' + suffix)
    return codes
    
if __name__ == '__main__':
    # Process Point File
    tkObj = Tkinter.Tk()
    tkObj.file_opt = options = {}
    pointFile = tkFileDialog.askopenfile('r')

    if pointFile:
        # '-', 'a', ... 'z'
        [userX, userY] = loadKeyboardLayout(pointFile.name)
        print 'Number: %d' % (len(userX[1:]))
        print 'userPosX = [' + ', '.join([str(i) for i in userX[1:]]) + ']'
        print 'userPosY = [' + ', '.join([str(i) for i in userY[1:]]) + ']'

    print '--------------\n'

    # 'a', 'b', ... 'z'
    [posX, posY] = calcKeyboardLayout()
    print 'Number: %d' % (len(posX))
    print 'letterPosX = [' + ', '.join([str(i) for i in posX]) + ']'
    print 'letterPosY = [' + ', '.join([str(i) for i in posY]) + ']'

    ax = gca()
    ax.set_xlim(400, 1500)
    ax.set_ylim(400, 1500)
    ax.invert_yaxis()

    plt.show()
    # plt.title('Surface Keyboard Layout')
    # gca().invert_yaxis()
    # plt.show()

    # [pntIdL, pntIdR, vecL, vecR] = calcWordVec('dog')
    # print [pntIdL, pntIdR, vecL, vecR]

    # Process Point-Pair File
    tkObj = Tkinter.Tk()
    tkObj.file_opt = options = {}
    pairFile = tkFileDialog.askopenfile('r')
    if pairFile:
        dataCSV = np.genfromtxt(pairFile.name, dtype = None, delimiter = ',', names = True)
        charPair = dataCSV['charPair']
        vecX = dataCSV['meanvecX']
        vecY = dataCSV['meanvecY']
        vecLen = dataCSV['meanvecLen']
        rad1 = dataCSV['meanradpipi']
        rad2 = dataCSV['meanrad02pi']

        vecParams = {}
        for (cP, vX, vY, vL, r1, r2) in zip(charPair, vecX, vecY, vecLen, rad1, rad2):
            vecParams[cP.strip('\'')] = (vX, vY, vL, r1, r2)

        for i in range(26):
            charI = chr(ord('a') + i)
            for j in range(26):
                charJ = chr(ord('a') + j)
                charIJ = charI + charJ
                if not {charIJ}.issubset(vecParams.keys()):
                    print 'Add: ' + charIJ
                    if charI == charJ:
                        vecParams[charIJ] = (0, 0, 0, 0, 0)
                    else:
                        vX = userX[j+1] - userX[i+1]
                        vY = userY[j+1] - userY[i+1]
                        vL = math.sqrt(math.pow(vX, 2) + math.pow(vY, 2))
                        r1 = 0
                        r2 = 0

                        if vL != 0:
                            if vY > 0:
                                r1 = math.acos(vX / vL)
                                r2 = r1
                            else:
                                r1 = -math.acos(vX / vL)
                                r2 = math.pi + math.acos(-vX / vL)

                        vecParams[charIJ] = (vX, vY, vL, r1, r2)

        vecParamsFile = file('vecParams.pkl', 'wb')
        pickle.dump(vecParams, vecParamsFile, True)
        print vecParams




